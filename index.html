<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>P2P Cyber Chat</title>
<style>
    /* --- Your Provided Theme Styles --- */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #1e1e2f, #3a3a5a);
      background-repeat: no-repeat;
      background-size: cover;
      background-attachment: fixed;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow-x: hidden;
    }

    h2 {
      font-size: 2rem;
      margin: 20px 0 10px 0;
      opacity: 0.9;
      text-shadow: 0 0 10px rgba(255,255,255,0.2);
    }

    /* --- Chat Layout Containers --- */
    .main-container {
      width: 90vw;
      max-width: 1000px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-bottom: 30px;
    }

    /* Glassmorphism Panel Style */
    .glass-panel {
      background-color: #ffffff11;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid #ffffff22;
      padding: 20px;
      box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
    }

    /* --- Peer List Styling --- */
    #peers {
      max-height: 150px;
      overflow-y: auto;
    }
    #peerList {
      list-style: none;
      padding: 0;
      margin: 10px 0 0 0;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 10px;
    }
    #peerList li {
      background: #ffffff11;
      padding: 10px 15px;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      transition: 0.3s;
      border: 1px solid transparent;
    }
    #peerList li:hover {
      background: #ffffff22;
      transform: translateY(-2px);
    }
    .connected-peer {
      border-color: #4CAF50 !important;
      background: rgba(76, 175, 80, 0.2) !important;
      font-weight: bold;
    }

    /* --- Messages Box (Larger) --- */
    #messages {
      height: 450px; /* Much larger */
      overflow-y: auto;
      padding: 15px;
      margin-bottom: 15px;
      background: rgba(0,0,0,0.2);
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    #messages div {
      padding: 8px 12px;
      border-radius: 18px;
      background: rgba(255,255,255,0.05);
      width: fit-content;
      max-width: 80%;
    }

    /* --- Controls & Inputs --- */
    .input-area {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    input[type="text"] {
      flex-grow: 1;
      padding: 12px 20px;
      border-radius: 50px;
      border: none;
      background: rgba(255,255,255,0.1);
      color: white;
      outline: none;
      font-size: 1rem;
    }
    input[type="text"]:focus {
      background: rgba(255,255,255,0.15);
      box-shadow: 0 0 10px rgba(255,255,255,0.1);
    }

    /* Buttons Style */
    button {
      padding: 10px 20px;
      border-radius: 50px;
      border: none;
      cursor: pointer;
      font-weight: bold;
      transition: 0.2s;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    #send { background: #4CAF50; color: white; }
    #send:hover { background: #45a049; transform: scale(1.05); }
    
    .file-btn { background: #ff9900; color: white; }
    .file-btn:hover { background: #ffb84d; transform: scale(1.05); }

    .disconnect-btn {
      background: #e74c3c;
      color: white;
      padding: 4px 10px;
      font-size: 0.75rem;
      border-radius: 4px;
    }
    
    #leaveAll { background: #333; color: white; }
    #leaveAll:hover { background: #444; }

    /* Custom Scrollbar */
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 10px; }
</style>
</head>
<body>

<h2>Direct P2P CyberChat</h2>
<p style="opacity: 0.7;">Logged in as: <span id="myName" style="color:#4CAF50; font-weight:bold;"></span></p>

<div class="main-container">
    <div id="peers" class="glass-panel">
        <strong>Online Peers</strong>
        <ul id="peerList"></ul>
    </div>

    <div class="glass-panel">
        <div id="messages"></div>
        <div class="input-area">
            <input type="text" id="msg" placeholder="Type a secure message...">
            <button id="send">Send</button>
            <input type="file" id="fileInput" style="display:none">
            <button class="file-btn" onclick="document.getElementById('fileInput').click()">üìé File</button>
            <button id="clearChat" style="background: rgba(255,255,255,0.1); color: white;">üóëÔ∏è Clear</button>
            <button id="leaveAll">üö™ Leave</button>
        </div>
    </div>
</div>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
/* --- YOUR EXISTING FIREBASE CONFIG --- */
const firebaseConfig = {
  apiKey: "AIzaSyAN4rqNgFUf_i6HHN6F1nxTiFYGXbB1D28",
  authDomain: "p2p-for-web.firebaseapp.com",
  databaseURL: "https://p2p-for-web-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "p2p-for-web",
  storageBucket: "p2p-for-web.firebasestorage.app",
  messagingSenderId: "142901996110",
  appId: "1:142901996110:web:e9e658fea4426bf754711f"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.database();

const myName = prompt("Enter your name:") || "Anonymous";
document.getElementById("myName").textContent = myName;
const myId = Math.random().toString(36).substring(2);

const peersRef = db.ref("peers");
const mySignalsRef = db.ref("signals/" + myId);

let connections = {};
let allPeers = {};
let incomingFile = { metadata: null, buffer: [] };

const log = (msg, id = null) => {
  const logDiv = document.getElementById("messages");
  if (id && document.getElementById(id)) {
    document.getElementById(id).innerHTML = msg;
  } else {
    const newLog = document.createElement("div");
    if (id) newLog.id = id;
    newLog.innerHTML = msg;
    logDiv.appendChild(newLog);
  }
  logDiv.scrollTop = logDiv.scrollHeight;
};

peersRef.child(myId).set({ name: myName });
peersRef.child(myId).onDisconnect().remove();

function renderPeerList() {
  const peerListEl = document.getElementById("peerList");
  peerListEl.innerHTML = "";
  for (let id in allPeers) {
    if (id === myId) continue;
    const li = document.createElement("li");
    const conn = connections[id];
    const isConnected = conn && conn.channel?.readyState === "open";
    if (isConnected) li.className = "connected-peer";
    
    li.innerHTML = `<span>${allPeers[id].name}${isConnected ? " (Active)" : ""}</span>`;
    const btnContainer = document.createElement("div");
    if (isConnected) {
      const btn = document.createElement("button");
      btn.textContent = "Drop";
      btn.className = "disconnect-btn";
      btn.onclick = (e) => { e.stopPropagation(); disconnectFromPeer(id); };
      btnContainer.appendChild(btn);
    } else {
      li.onclick = () => {
        const statusId = `status-${id}`;
        log(`<b>Connecting to ${allPeers[id].name}...</b>`, statusId);
        startCall(id);
      };
    }
    li.appendChild(btnContainer);
    peerListEl.appendChild(li);
  }
}

peersRef.on("value", snap => {
  allPeers = snap.val() || {};
  renderPeerList();
});

function disconnectFromPeer(id) {
  const conn = connections[id];
  if (conn) {
    if (conn.channel?.readyState === "open") {
      try { conn.channel.send(JSON.stringify({ type: "system-bye" })); } catch(e) {}
    }
    conn.pc.close();
    delete connections[id];
    log(`<i>Disconnected from ${allPeers[id]?.name || id}</i>`);
    renderPeerList();
  }
}

window.onbeforeunload = () => {
  for (let id in connections) {
    if (connections[id].channel?.readyState === "open") {
      connections[id].channel.send(JSON.stringify({ type: "system-bye" }));
    }
  }
  peersRef.child(myId).remove();
};

function createPeerConnection(peerId) {
  const pc = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });
  connections[peerId] = { pc, channel: null };
  const peerName = allPeers[peerId]?.name || "Peer";

  pc.onicecandidate = e => {
    if (e.candidate) db.ref("signals/" + peerId).push({ from: myId, candidate: e.candidate.toJSON() });
  };
  pc.ondatachannel = e => setupChannel(peerId, e.channel);
  pc.onconnectionstatechange = () => {
    log(`Peer <b>${peerName}</b>: <b>${pc.connectionState}</b>`, `status-${peerId}`);
    renderPeerList();
  };
  return pc;
}

async function startCall(peerId) {
  const pc = createPeerConnection(peerId);
  const channel = pc.createDataChannel("chat");
  setupChannel(peerId, channel);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  db.ref("signals/" + peerId).push({ from: myId, offer: offer });
}

mySignalsRef.on("child_added", async snap => {
  const { from, offer, answer, candidate } = snap.val();
  snap.ref.remove();
  const statusId = `status-${from}`;
  if (!connections[from]) {
    if (offer) log(`<b>Connecting with ${allPeers[from]?.name || "Peer"}...</b>`, statusId);
    createPeerConnection(from);
  }
  const pc = connections[from].pc;
  if (offer) {
    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    const myAnswer = await pc.createAnswer();
    await pc.setLocalDescription(myAnswer);
    db.ref("signals/" + from).push({ from: myId, answer: myAnswer });
  } else if (answer) {
    await pc.setRemoteDescription(new RTCSessionDescription(answer));
  } else if (candidate) {
    await pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(e => {});
  }
});

function setupChannel(peerId, channel) {
  connections[peerId].channel = channel;
  channel.binaryType = "arraybuffer";
  const peerName = allPeers[peerId]?.name || "Peer";
  channel.onopen = () => {
    log(`<span style='color:#4CAF50; font-weight:bold;'>CONNECTION ENCRYPTED WITH ${peerName.toUpperCase()}</span>`, `status-${peerId}`);
    renderPeerList();
  };
  channel.onmessage = e => {
    if (typeof e.data === "string") {
      try {
        const obj = JSON.parse(e.data);
        if (obj.type === "file-meta") {
          incomingFile = { metadata: obj, buffer: [] };
          log(`<i>Receiving: ${obj.name}</i>`);
          return;
        }
        if (obj.type === "system-bye") {
          log(`<i>${peerName} left.</i>`);
          if (connections[peerId]) { connections[peerId].pc.close(); delete connections[peerId]; }
          renderPeerList();
          return;
        }
      } catch (err) {}
      log(`<b>${peerName}:</b> ${e.data}`);
    } else {
      incomingFile.buffer.push(e.data);
      const receivedSize = incomingFile.buffer.reduce((acc, cur) => acc + cur.byteLength, 0);
      if (receivedSize >= incomingFile.metadata.size) {
        const blob = new Blob(incomingFile.buffer, { type: incomingFile.metadata.mime });
        processCompletedFile(blob, incomingFile.metadata, peerName);
        incomingFile = { metadata: null, buffer: [] };
      }
    }
  };
  channel.onclose = () => { renderPeerList(); };
}

function processCompletedFile(blob, meta, senderName) {
  const url = URL.createObjectURL(blob);
  if (meta.mime.startsWith("image/")) {
    log(`<b>${senderName}:</b><br><img src="${url}" style="max-width:300px; border-radius:8px; border:1px solid #555; margin-top:5px;">`);
  } else if (meta.mime.startsWith("video/")) {
    log(`<b>${senderName}:</b><br><video controls style="max-width:300px; border-radius:8px; margin-top:5px;"><source src="${url}" type="${meta.mime}"></video>`);
  } else {
    log(`<b>${senderName}:</b> <a href="${url}" download="${meta.name}" style="color:#ff9900">Download ${meta.name}</a>`);
  }
}

function broadcast(data) {
  for (let id in connections) {
    if (connections[id].channel?.readyState === "open") connections[id].channel.send(data);
  }
}

document.getElementById("send").onclick = sendMessage;
document.getElementById("msg").onkeypress = e => { if(e.key === "Enter") sendMessage(); };

function sendMessage() {
  const msgInput = document.getElementById("msg");
  const val = msgInput.value.trim();
  if (!val) return;
  broadcast(val);
  log(`<b>You:</b> ${val}`);
  msgInput.value = "";
}

document.getElementById("fileInput").onchange = async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const buffer = await file.arrayBuffer();
  broadcast(JSON.stringify({ type: "file-meta", name: file.name, mime: file.type, size: file.size }));
  const chunkSize = 16384;
  for (let i = 0; i < buffer.byteLength; i += chunkSize) {
    broadcast(buffer.slice(i, i + chunkSize));
  }
  processCompletedFile(new Blob([buffer], {type: file.type}), {mime: file.type, name: file.name}, "You");
  e.target.value = "";
};

document.getElementById("leaveAll").onclick = () => {
  if (!confirm("Disconnect from all secure channels?")) return;
  for (let id in connections) {
    if (connections[id].channel?.readyState === "open") {
      try { connections[id].channel.send(JSON.stringify({ type: "system-bye" })); } catch (e) {}
    }
    connections[id].pc.close();
  }
  connections = {};
  peersRef.child(myId).remove().then(() => {
    log("<b style='color:#e74c3c;'>OFFLINE</b>");
    renderPeerList();
  });
};
// --- Clear Chat Logic ---
document.getElementById("clearChat").onclick = () => {
  const logDiv = document.getElementById("messages");
  
  // 1. Wipe the UI
  logDiv.innerHTML = "";
  
  // 2. Reset the incoming file buffer just in case a transfer was stuck
  incomingFile = { metadata: null, buffer: [] };
  
  // 3. Add a little status tip
  log("<i style='opacity:0.5;'>Chat history cleared locally.</i>");
};
</script>
</body>
</html>
