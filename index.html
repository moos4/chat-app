<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>P2P Cyber Chat</title>
<style>
    body {
      margin: 0; padding: 0;
      font-family: 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #1e1e2f, #3a3a5a);
      background-repeat: no-repeat; background-size: cover; background-attachment: fixed;
      color: #fff; display: flex; flex-direction: column; align-items: center; min-height: 100vh;
    }

    h2 { font-size: 2rem; margin: 20px 0 10px 0; opacity: 0.9; text-shadow: 0 0 10px rgba(255,255,255,0.2); }

    .main-container { width: 90vw; max-width: 1000px; display: flex; flex-direction: column; gap: 20px; margin-bottom: 30px; }

    .glass-panel {
      background-color: #ffffff11; border-radius: 15px; backdrop-filter: blur(10px);
      border: 1px solid #ffffff22; padding: 20px; box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
    }

    #peers { max-height: 150px; overflow-y: auto; }
    #peerList { list-style: none; padding: 0; margin: 10px 0 0 0; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; }
    
    #peerList li {
      background: #ffffff11; padding: 10px 15px; border-radius: 8px; display: flex;
      justify-content: space-between; align-items: center; cursor: pointer; transition: 0.3s;
    }
    #peerList li:hover { background: #ffffff22; transform: translateY(-2px); }
    .connected-peer { border: 1px solid #4CAF50 !important; background: rgba(76, 175, 80, 0.2) !important; }

    #messages {
      height: 450px; overflow-y: auto; padding: 15px; margin-bottom: 15px;
      background: rgba(0,0,0,0.2); border-radius: 10px; display: flex; flex-direction: column; gap: 8px;
    }
    #messages div { padding: 8px 12px; border-radius: 18px; background: rgba(255,255,255,0.05); width: fit-content; max-width: 80%; }

    .input-area { display: flex; gap: 10px; align-items: center; }
    input[type="text"] { flex-grow: 1; padding: 12px 20px; border-radius: 50px; border: none; background: rgba(255,255,255,0.1); color: white; outline: none; }

    button { padding: 10px 20px; border-radius: 50px; border: none; cursor: pointer; font-weight: bold; transition: 0.2s; display: flex; align-items: center; gap: 5px; }
    #send { background: #4CAF50; color: white; }
    .file-btn { background: #ff9900; color: white; }
    .disconnect-btn { background: #e74c3c; color: white; padding: 4px 10px; font-size: 0.75rem; border-radius: 4px; }
    #leaveAll { background: #333; color: white; }

    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 10px; }
</style>
</head>
<body>

<h2>Direct P2P CyberChat</h2>
<p style="opacity: 0.7;">Logged in as: <span id="myName" style="color:#4CAF50; font-weight:bold;"></span></p>

<div class="main-container">
    <div id="peers" class="glass-panel">
        <strong>Online Peers</strong>
        <ul id="peerList"></ul>
    </div>

    <div class="glass-panel">
        <div id="messages"></div>
        <div class="input-area">
            <input type="text" id="msg" placeholder="Type a secure message...">
            <button id="send">Send</button>
            <input type="file" id="fileInput" style="display:none">
            <button class="file-btn" onclick="document.getElementById('fileInput').click()">üìé File</button>
            <button id="clearChat" style="background: rgba(255,255,255,0.1); color: white;">üóëÔ∏è Clear</button>
            <button id="leaveAll">üö™ Leave</button>
        </div>
    </div>
</div>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyAN4rqNgFUf_i6HHN6F1nxTiFYGXbB1D28",
  authDomain: "p2p-for-web.firebaseapp.com",
  databaseURL: "https://p2p-for-web-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "p2p-for-web",
  storageBucket: "p2p-for-web.firebasestorage.app",
  messagingSenderId: "142901996110",
  appId: "1:142901996110:web:e9e658fea4426bf754711f"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.database();

const myName = prompt("Enter your name:") || "Anonymous";
document.getElementById("myName").textContent = myName;
const myId = Math.random().toString(36).substring(2);

const peersRef = db.ref("peers");
const mySignalsRef = db.ref("signals/" + myId);

let connections = {};
let allPeers = {};
let incomingFile = { metadata: null, buffer: [] };

const log = (msg, id = null) => {
  const logDiv = document.getElementById("messages");
  if (id && document.getElementById(id)) {
    document.getElementById(id).innerHTML = msg;
  } else {
    const newLog = document.createElement("div");
    if (id) newLog.id = id;
    newLog.innerHTML = msg;
    logDiv.appendChild(newLog);
  }
  logDiv.scrollTop = logDiv.scrollHeight;
};

peersRef.child(myId).set({ name: myName });
peersRef.child(myId).onDisconnect().remove();

function renderPeerList() {
  const peerListEl = document.getElementById("peerList");
  peerListEl.innerHTML = "";
  for (let id in allPeers) {
    if (id === myId) continue;
    const li = document.createElement("li");
    const conn = connections[id];
    const isConnected = conn && conn.channel?.readyState === "open";
    if (isConnected) li.className = "connected-peer";
    
    li.innerHTML = `<span>${allPeers[id].name}${isConnected ? " (Active)" : ""}</span>`;
    const btnContainer = document.createElement("div");
    if (isConnected) {
      const btn = document.createElement("button");
      btn.textContent = "Drop";
      btn.className = "disconnect-btn";
      btn.onclick = (e) => { e.stopPropagation(); disconnectFromPeer(id); };
      btnContainer.appendChild(btn);
    } else {
      li.onclick = () => {
        log(`<b>Connecting to ${allPeers[id].name}...</b>`, `status-${id}`);
        startCall(id);
      };
    }
    li.appendChild(btnContainer);
    peerListEl.appendChild(li);
  }
}

peersRef.on("value", snap => {
  allPeers = snap.val() || {};
  renderPeerList();
});

function disconnectFromPeer(id) {
  const conn = connections[id];
  if (conn) {
    if (conn.timeout) clearTimeout(conn.timeout);
    if (conn.channel?.readyState === "open") {
      try { conn.channel.send(JSON.stringify({ type: "system-bye" })); } catch(e) {}
    }
    conn.pc.close();
    delete connections[id];
    log(`<i>Disconnected from ${allPeers[id]?.name || id}</i>`);
    renderPeerList();
  }
}

function createPeerConnection(peerId) {
  const pc = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });
  
  // Set a 15-second timeout for the connection process
  const connectionTimeout = setTimeout(() => {
    if (connections[peerId] && (!connections[peerId].channel || connections[peerId].channel.readyState !== "open")) {
      log(`<b style="color:#e74c3c;">Connection to ${allPeers[peerId]?.name || 'Peer'} timed out.</b>`, `status-${peerId}`);
      disconnectFromPeer(peerId);
    }
  }, 15000);

  connections[peerId] = { pc, channel: null, timeout: connectionTimeout };
  const peerName = allPeers[peerId]?.name || "Peer";

  pc.onicecandidate = e => {
    if (e.candidate) db.ref("signals/" + peerId).push({ from: myId, candidate: e.candidate.toJSON() });
  };
  pc.ondatachannel = e => setupChannel(peerId, e.channel);
  pc.onconnectionstatechange = () => {
    log(`Peer <b>${peerName}</b>: <b>${pc.connectionState}</b>`, `status-${peerId}`);
    if (pc.connectionState === "connected" && connections[peerId].timeout) {
        clearTimeout(connections[peerId].timeout);
    }
    renderPeerList();
  };
  return pc;
}

async function startCall(peerId) {
  const pc = createPeerConnection(peerId);
  const channel = pc.createDataChannel("chat");
  setupChannel(peerId, channel);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  db.ref("signals/" + peerId).push({ from: myId, offer: offer });
}

mySignalsRef.on("child_added", async snap => {
  const { from, offer, answer, candidate } = snap.val();
  snap.ref.remove();
  if (!connections[from]) {
    if (offer) log(`<b>Connecting with ${allPeers[from]?.name || "Peer"}...</b>`, `status-${from}`);
    createPeerConnection(from);
  }
  const pc = connections[from].pc;
  if (offer) {
    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    const myAnswer = await pc.createAnswer();
    await pc.setLocalDescription(myAnswer);
    db.ref("signals/" + from).push({ from: myId, answer: myAnswer });
  } else if (answer) {
    await pc.setRemoteDescription(new RTCSessionDescription(answer));
  } else if (candidate) {
    await pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(e => {});
  }
});

function setupChannel(peerId, channel) {
  connections[peerId].channel = channel;
  channel.binaryType = "arraybuffer";
  const peerName = allPeers[peerId]?.name || "Peer";
  
  channel.onopen = () => {
    if (connections[peerId].timeout) clearTimeout(connections[peerId].timeout);
    log(`<span style='color:#4CAF50; font-weight:bold;'>ENCRYPTED WITH ${peerName.toUpperCase()}</span>`, `status-${peerId}`);
    renderPeerList();
  };
  
  channel.onmessage = e => {
    if (typeof e.data === "string") {
      try {
        const obj = JSON.parse(e.data);
        if (obj.type === "file-meta") {
          incomingFile = { metadata: obj, buffer: [] };
          log(`<i>Receiving: ${obj.name}</i>`);
          return;
        }
        if (obj.type === "system-bye") {
          log(`<i>${peerName} left.</i>`);
          disconnectFromPeer(peerId);
          return;
        }
      } catch (err) {}
      log(`<b>${peerName}:</b> ${e.data}`);
    } else {
      incomingFile.buffer.push(e.data);
      const receivedSize = incomingFile.buffer.reduce((acc, cur) => acc + cur.byteLength, 0);
      if (receivedSize >= incomingFile.metadata.size) {
        const blob = new Blob(incomingFile.buffer, { type: incomingFile.metadata.mime });
        processCompletedFile(blob, incomingFile.metadata, peerName);
        incomingFile = { metadata: null, buffer: [] };
      }
    }
  };
}

function processCompletedFile(blob, meta, senderName) {
  const url = URL.createObjectURL(blob);
  const isImage = meta.mime.startsWith("image/");
  const isVideo = meta.mime.startsWith("video/");
  let content = isImage ? `<img src="${url}" style="max-width:300px; border-radius:8px; border:1px solid #555; margin-top:5px;">` :
                isVideo ? `<video controls style="max-width:300px; border-radius:8px; margin-top:5px;"><source src="${url}" type="${meta.mime}">Fallback</video><br><a href="${url}" download="${meta.name}" style="color:#ff9900; font-size: 0.8rem;">üì• Download ${meta.name}</a>` :
                `<a href="${url}" download="${meta.name}" style="color:#ff9900">Download ${meta.name}</a>`;
  log(`<b>${senderName}:</b><br>${content}`);
}

function broadcast(data) {
  for (let id in connections) {
    if (connections[id].channel?.readyState === "open") connections[id].channel.send(data);
  }
}

document.getElementById("send").onclick = sendMessage;
document.getElementById("msg").onkeypress = e => { if(e.key === "Enter") sendMessage(); };
function sendMessage() {
  const msgInput = document.getElementById("msg");
  const val = msgInput.value.trim();
  if (!val) return;
  broadcast(val);
  log(`<b>You:</b> ${val}`);
  msgInput.value = "";
}

document.getElementById("fileInput").onchange = async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const buffer = await file.arrayBuffer();
  broadcast(JSON.stringify({ type: "file-meta", name: file.name, mime: file.type, size: file.size }));
  const chunkSize = 16384;
  for (let i = 0; i < buffer.byteLength; i += chunkSize) broadcast(buffer.slice(i, i + chunkSize));
  processCompletedFile(new Blob([buffer], {type: file.type}), {mime: file.type, name: file.name}, "You");
  e.target.value = "";
};

document.getElementById("clearChat").onclick = () => {
  document.getElementById("messages").innerHTML = "";
  incomingFile = { metadata: null, buffer: [] };
  log("<i style='opacity:0.5;'>Chat history cleared locally.</i>");
};

document.getElementById("leaveAll").onclick = () => {
  if (!confirm("Disconnect from everyone?")) return;
  for (let id in connections) disconnectFromPeer(id);
  peersRef.child(myId).remove().then(() => { log("<b style='color:#e74c3c;'>OFFLINE</b>"); renderPeerList(); });
};

window.onbeforeunload = () => {
  for (let id in connections) disconnectFromPeer(id);
  peersRef.child(myId).remove();
};
</script>
</body>
</html>