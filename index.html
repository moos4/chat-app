<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>P2P Chat App</title>
<style>
    body {
      margin: 0; padding: 0;
      font-family: 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #1e1e2f, #3a3a5a);
      background-repeat: no-repeat; background-size: cover; background-attachment: fixed;
      color: #fff; display: flex; flex-direction: column; align-items: center; min-height: 100vh;
    }

    h2 { font-size: 2rem; margin: 20px 0 10px 0; opacity: 0.9; text-shadow: 0 0 10px rgba(255,255,255,0.2); }

    .main-container { width: 90vw; max-width: 1000px; display: flex; flex-direction: column; gap: 20px; margin-bottom: 30px; }

    .glass-panel {
      background-color: #ffffff11; border-radius: 15px; backdrop-filter: blur(10px);
      border: 1px solid #ffffff22; padding: 20px; box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
    }

    #peers { max-height: 150px; overflow-y: auto; }
    #peerList { list-style: none; padding: 0; margin: 10px 0 0 0; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; }
    
    #peerList li {
      background: #ffffff11; padding: 10px 15px; border-radius: 8px; display: flex;
      justify-content: space-between; align-items: center; cursor: pointer; transition: 0.3s;
    }
    #peerList li:hover { background: #ffffff22; transform: translateY(-2px); }
    .connected-peer { border: 1px solid #4CAF50 !important; background: rgba(76, 175, 80, 0.2) !important; }

    #messages {
      height: 450px; overflow-y: auto; padding: 15px; margin-bottom: 15px;
      background: rgba(0,0,0,0.2); border-radius: 10px; display: flex; flex-direction: column; gap: 8px;
    }
    #messages div { padding: 8px 12px; border-radius: 18px; background: rgba(255,255,255,0.05); width: fit-content; max-width: 80%; }

    .input-area { display: flex; gap: 10px; align-items: center; }
    input[type="text"] { flex-grow: 1; padding: 12px 20px; border-radius: 50px; border: none; background: rgba(255,255,255,0.1); color: white; outline: none; }

    button { padding: 10px 20px; border-radius: 50px; border: none; cursor: pointer; font-weight: bold; transition: 0.2s; display: flex; align-items: center; gap: 5px; }
    #send { background: #4CAF50; color: white; }
    .file-btn { background: #ff9900; color: white; }
    .disconnect-btn { background: #e74c3c; color: white; padding: 4px 10px; font-size: 0.75rem; border-radius: 4px; }
    #leaveAll { background: #333; color: white; }

    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 10px; }
    .spoiler {
      background-color: #555;
      color: transparent;
      border-radius: 4px;
      padding: 0 2px;
      cursor: pointer;
      transition: background 0.3s, color 0.3s;
    }
    .spoiler.revealed {
      background-color: rgba(255,255,255,0.1);
      color: inherit;
    }
    /* The switch container */
    .switch {
      position: relative;
          display: inline-block;
      width: 40px;
      height: 20px;
    }
    
    /* Hide default checkbox */
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    /* The slider */
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(255,255,255,0.2);
      transition: .4s;
      border-radius: 20px;
    }
    
    .slider:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .slider {
      background-color: #4CAF50;
    }
    
    input:checked + .slider:before {
      transform: translateX(20px);
    }
    .mention-highlight {
      background: rgba(255, 193, 7, 0.3) !important; /* Gold/Amber highlight */
      border: 1px solid #ffc107;
      animation: pulse-border 2s infinite;
    }

    @keyframes pulse-border {
      0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }
    }
    
    #typingIndicator {
      height: 20px;
      font-size: 0.85rem;
      font-style: italic;
      color: #4CAF50;
      margin-top: -10px;
      margin-bottom: 5px;
      padding-left: 10px;
      opacity: 0.8;
    }
</style>
</head>
<body>
<audio id="notifSound" src="https://assets.mixkit.co/active_storage/sfx/2354/2354-preview.mp3" preload="auto"></audio>
<audio id="mentionSound" src="https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3" preload="auto"></audio>
<h2>Direct P2P Chat App</h2>
<p style="opacity: 0.7;">Logged in as: <span id="myName" style="color:#4CAF50; font-weight:bold;"></span></p>

<div class="main-container">
    <div id="peers" class="glass-panel">
        <strong>Online Peers</strong>
        <ul id="peerList"></ul>
    </div>

    <div class="glass-panel">
        <div id="messages"></div>
        <div id="typingIndicator"></div>
        <div class="input-area">
            <textarea id="msg" placeholder="Type a secure message..." rows="1" style="flex-grow: 1; padding: 12px 20px; border-radius: 15px; border: none; background: rgba(255,255,255,0.1); color: white; outline: none; resize: none; font-family: inherit;"></textarea>
            <button id="send">Send</button>
            <input type="file" id="fileInput" style="display:none">
            <button class="file-btn" onclick="document.getElementById('fileInput').click()">üìé File</button>
            <button id="clearChat" style="background: rgba(255,255,255,0.1); color: white;">üóëÔ∏è Clear</button>
            <button id="leaveAll">üö™ Leave</button>
            <div style="display: flex; align-items: center; gap: 10px; margin-left: 10px;">
              <span style="font-size: 0.8rem; opacity: 0.8;">Notifications</span>
              <label class="switch">
                <input type="checkbox" id="notifToggle">
                <span class="slider"></span>
              </label>
            </div>
        </div>
    </div>
</div>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyAN4rqNgFUf_i6HHN6F1nxTiFYGXbB1D28",
  authDomain: "p2p-for-web.firebaseapp.com",
  databaseURL: "https://p2p-for-web-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "p2p-for-web",
  storageBucket: "p2p-for-web.firebasestorage.app",
  messagingSenderId: "142901996110",
  appId: "1:142901996110:web:e9e658fea4426bf754711f"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.database();
const peersRef = db.ref("peers");

let myName = "";
let myId = Math.random().toString(36).substring(2);
let connections = {};
let allPeers = {};
let incomingFile = { metadata: null, buffer: [] };

let isTabActive = true;

// Notifications
let desktopNotificationsEnabled = false;
const notifCheck = document.getElementById("notifToggle");

notifCheck.onchange = async () => {
  // 1. Check if the browser even supports it
  if (!("Notification" in window)) {
    alert("This browser does not support desktop notifications.");
    notifCheck.checked = false;
    return;
  }

  // 2. If the user is turning it ON
  if (notifCheck.checked) {
    // Request permission
    const permission = await Notification.requestPermission();
    
    if (permission === "granted") {
      desktopNotificationsEnabled = true;
      // Send a test notification immediately so the user knows it worked
      new Notification("Notifications Enabled!", {
        body: "You will now see alerts when you are in another tab.",
        icon: "https://cdn-icons-png.flaticon.com/512/733/733585.png"
      });
    } else {
      // If they clicked "Block" or closed the popup
      alert("Permission not granted. Please click the lock icon in your address bar and set Notifications to 'Allow'.");
      desktopNotificationsEnabled = false;
      notifCheck.checked = false;
    }
  } else {
    // 3. Turning it OFF
    desktopNotificationsEnabled = false;
  }
};


function notifyUser(senderName, messageText) {
  if (!isTabActive) {
    // Sound
    const sound = document.getElementById("notifSound");
    if (sound) sound.play().catch(() => {});

    // Tab Flash
    document.title = "üî¥ New Message!";

    // Desktop Popup
    if (desktopNotificationsEnabled && Notification.permission === "granted") {
      const n = new Notification(`P2P: ${senderName}`, {
        body: messageText.length > 80 ? messageText.substring(0, 77) + "..." : messageText,
        icon: "https://cdn-icons-png.flaticon.com/512/733/733585.png"
      });
      
      n.onclick = () => {
        window.focus();
        n.close();
      };
    }
  }
}

// --- Security: Escape HTML to prevent XSS ---
function escapeHTML(str) {
  const p = document.createElement("p");
  p.textContent = str;
  return p.innerHTML;
}

// --- Updated Markdown Helper ---
function applyMarkdown(text) {
  return text
    // Spolers
    .replace(/\|\|(.*?)\|\|/g, '<span class="spoiler" onclick="this.classList.toggle(\'revealed\')">$1</span>')
    
    // Headers (Start of line only)
    .replace(/^#### (.*$)/gm, '<h4>$1</h4>')
    .replace(/^### (.*$)/gm, '<h3>$1</h3>')
    .replace(/^## (.*$)/gm, '<h2>$1</h2>')
    .replace(/^# (.*$)/gm, '<h1>$1</h1>')
    .replace(/^-# (.*$)/gm, '<small style="display:block; opacity:0.7;">$1</small>')
    
    // Standard Formatting
    .replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>')
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    .replace(/__(.*?)__/g, '<u>$1</u>')
    .replace(/~~(.*?)~~/g, '<del>$1</del>')
    .replace(/`([\s\S]*?)`/g, '<pre><code>$1</code></pre>')
    
    //.replace(/\((.*?)\)/g, '<button>$1</button>')
    
    // Handle New Lines
    .replace(/\n/g, '<br>');
}

// --- Shift + Enter Logic ---
const msgInput = document.getElementById("msg");
msgInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    if (e.shiftKey) {
      // Shift + Enter: Do nothing, let the browser add a new line
      return;
    } else {
      // Enter only: Send message
      e.preventDefault(); // Stop the new line from being added
      sendMessage();
    }
  }
});

// Auto-resize textarea as you type
msgInput.addEventListener("input", function() {
  this.style.height = 'auto';
  this.style.height = (this.scrollHeight - 24) + 'px';
  if (this.scrollHeight > 200) this.style.overflowY = "auto";
});

let lastTypingSent = 0;

msgInput.addEventListener("input", () => {
  const now = Date.now();
  // Only send the "typing" signal once every 2 seconds so we don't spam
  if (now - lastTypingSent > 5000) {
    broadcast(JSON.stringify({ type: "system-typing" }));
    lastTypingSent = now;
  }
});

// --- Advanced Link Detection ---

function linkify(text) {
  const urlRegex = /((https?:\/\/)|(www\.))?([a-zA-Z0-9-]+\.)+(com|net|org|nl|eu|uk|de|io|be|edu|gov|me|ai|biz|shop|store|xyz|co)([/\w\.-]*)*(\?[^?\s]*)?(#[^\s]*)?/gi;

  return text.replace(urlRegex, (url) => {
    let href = url;
    if (!href.match(/^https?:\/\//i)) {
      href = 'https://' + href;
    }

    const lowerHref = href.toLowerCase();
    let embedHtml = '';

    // 1. Image Embeds
    if (lowerHref.match(/\.(jpeg|jpg|gif|png|webp)$/)) {
      embedHtml = `<br><img src="${href}" style="max-width: 100%; max-height: 300px; border-radius: 10px; margin-top: 10px; display: block;" onerror="this.style.display='none'">`;
    }
    // 2. YouTube Embeds (Regular and Shorts)
    else if (lowerHref.includes("youtube.com") || lowerHref.includes("youtu.be")) {
      let videoId = "";
      
      if (lowerHref.includes("shorts/")) {
        videoId = href.split('shorts/')[1].split(/[?#]/)[0];
      } else if (lowerHref.includes("v=")) {
        videoId = href.split('v=')[1].split('&')[0];
      } else if (lowerHref.includes("youtu.be/")) {
        videoId = href.split('/').pop().split(/[?#]/)[0];
      }

      if (videoId) {
        // We use youtube-nocookie.com to bypass school filters and privacy blocks
        // We also add ?rel=0 to show related videos only from the same channel
        const embedUrl = `https://www.youtube-nocookie.com/embed/${videoId}?rel=0`;
        
        // Dynamic sizing: Shorts get vertical, others get horizontal
        const isShort = lowerHref.includes("shorts/");
        const width = isShort ? "315" : "100%";
        const height = isShort ? "560" : "315";

        embedHtml = `<br><iframe width="${width}" height="${height}" src="${embedUrl}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="border-radius:10px; margin-top:10px; max-width:100%;"></iframe>`;
      }
    }
    // 3. Raw Video Embeds
    else if (lowerHref.match(/\.(mp4|webm|ogg)$/)) {
      embedHtml = `<br><video controls style="max-width: 100%; border-radius: 10px; margin-top: 10px;"><source src="${href}">Your browser does not support the video tag.</video>`;
    }

    return `<a href="${href}" target="_blank" rel="noopener noreferrer" style="color: #4CAF50; text-decoration: underline; font-weight: bold;">${url}</a>${embedHtml}`;
  });
}
// --- Updated Log Function ---
const log = (msg, id = null, isMention = false) => {
  const logDiv = document.getElementById("messages");
  let finalContent;

  // Existing logic for labels/system messages
  if (id && id.startsWith('status-')) {
    finalContent = msg;
  }
  else if (typeof msg === 'object' && msg.html) {
    finalContent = msg.html;
  }
  else if (typeof msg === 'string' && (msg.startsWith('<img') || msg.startsWith('<video') || msg.startsWith('<a'))) {
    finalContent = msg;
  }
  else if (typeof msg === 'string') {
    const safeText = escapeHTML(msg);
    const markedUp = applyMarkdown(safeText);
    finalContent = linkify(markedUp);
  }
  else {
    finalContent = msg;
  }

  if (id && document.getElementById(id)) {
    document.getElementById(id).innerHTML = finalContent;
  } else {
    const newLog = document.createElement("div");
    if (id) newLog.id = id;
    
    // This is the line that uses the variable
    if (isMention) newLog.className = "mention-highlight";
    
    newLog.innerHTML = finalContent;
    logDiv.appendChild(newLog);
  }
  logDiv.scrollTop = logDiv.scrollHeight;
};

// --- Login with Unique Name Check ---
async function login() {
  let nameChoice = prompt("Enter your name:");
  if (!nameChoice) nameChoice = "Anonymous";

  const snapshot = await peersRef.once("value");
  const currentPeers = snapshot.val() || {};
  const existingNames = Object.values(currentPeers).map(p => p.name.toLowerCase());

  if (existingNames.includes(nameChoice.toLowerCase())) {
    alert("That name is already in use. Please pick another one.");
    return login();
  }

  myName = nameChoice;
  document.getElementById("myName").textContent = myName;
  peersRef.child(myId).set({ name: myName });
  peersRef.child(myId).onDisconnect().remove();
  initSignalListener();
}

// --- Peer List (Updated to remove IDs and refresh properly) ---
function renderPeerList() {
  const peerListEl = document.getElementById("peerList");
  peerListEl.innerHTML = "";
  for (let id in allPeers) {
    if (id === myId) continue;
    
    const li = document.createElement("li");
    const conn = connections[id];
    const isConnected = conn && conn.channel?.readyState === "open";
    if (isConnected) li.className = "connected-peer";
    
    li.innerHTML = `<span>${allPeers[id].name}${isConnected ? " (Active)" : ""}</span>`;

    const btnContainer = document.createElement("div");
    if (isConnected) {
      const btn = document.createElement("button");
      btn.textContent = "Drop";
      btn.className = "disconnect-btn";
      btn.onclick = (e) => { e.stopPropagation(); disconnectFromPeer(id); };
      btnContainer.appendChild(btn);
    } else {
      li.onclick = () => {
        log(`<b>Connecting to ${allPeers[id].name}...</b>`, `status-${id}`, false);
        startCall(id);
      };
    }
    li.appendChild(btnContainer);
    peerListEl.appendChild(li);
  }
}

peersRef.on("value", snap => {
  allPeers = snap.val() || {};
  renderPeerList();
});

function disconnectFromPeer(id) {
  const conn = connections[id];
  if (conn) {
    if (conn.timeout) clearTimeout(conn.timeout);
    if (conn.channel?.readyState === "open") {
      try { conn.channel.send(JSON.stringify({ type: "system-bye" })); } catch(e) {}
    }
    conn.pc.close();
    delete connections[id];
    log({ html: `<i>Disconnected from ${allPeers[id]?.name || "peer"}</i>` });
    renderPeerList();
  }
}

// --- WebRTC Core ---
function createPeerConnection(peerId) {
  /*
  const pc = new RTCPeerConnection({
    iceServers: [
      { urls: "stun:stun.l.google.com:19302" },
      { urls: "stun:stun1.l.google.com:19302" }, // Backup STUN
      {
        urls: "turn:relay.metered.ca:80?transport=tcp",
        username: "6f6c5c3e0f945ec81eda71b7", // REPLACE with your private Metered username
        credential: "DxfCox0lm/bNgDcG" // REPLACE with your private Metered credential
      }
    ]
  });*/
  const pc = new RTCPeerConnection({
    iceServers: [
      {
        // Use TURNS (Secure) over 443.
        // This is the hardest for school firewalls to block.
        urls: "turns:global.relay.metered.ca:443?transport=tcp",
        username: "6f6c5c3e0f945ec81eda71b7",
        credential: "DxfCox0lm/bNgDcG"
      }
    ],
    // This forces the 'Relay' candidate and ignores local/STUN candidates
    iceTransportPolicy: "relay"
  });
  
  // Increase timeout to 20s for slow school networks
  const connectionTimeout = setTimeout(() => {
    if (connections[peerId] && (!connections[peerId].channel || connections[peerId].channel.readyState !== "open")) {
      log({ html: `<b style="color:#e74c3c;">Connection Failed: Firewall blocked P2P for ${allPeers[peerId]?.name || 'Peer'}</b>` }, `status-${peerId}`);
      disconnectFromPeer(peerId);
    }
  }, 20000);

  connections[peerId] = { pc, channel: null, timeout: connectionTimeout };
  
  pc.onicecandidate = e => {
    if (e.candidate) db.ref("signals/" + peerId).push({ from: myId, candidate: e.candidate.toJSON() });
  };
  
  pc.ondatachannel = e => setupChannel(peerId, e.channel);
  
  pc.onconnectionstatechange = () => {
    if (pc.connectionState === "connected" && connections[peerId].timeout) {
        clearTimeout(connections[peerId].timeout);
    }
    if (["disconnected", "failed", "closed"].includes(pc.connectionState)) {
        disconnectFromPeer(peerId);
    }
    renderPeerList();
  };
  return pc;
}

async function startCall(peerId) {
  const pc = createPeerConnection(peerId);
  const channel = pc.createDataChannel("chat");
  setupChannel(peerId, channel);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  db.ref("signals/" + peerId).push({ from: myId, offer: offer });
}

function initSignalListener() {
  db.ref("signals/" + myId).on("child_added", async snap => {
    const { from, offer, answer, candidate } = snap.val();
    snap.ref.remove();
    if (!connections[from]) createPeerConnection(from);
    
    const pc = connections[from].pc;
    if (offer) {
      await pc.setRemoteDescription(new RTCSessionDescription(offer));
      const myAnswer = await pc.createAnswer();
      await pc.setLocalDescription(myAnswer);
      db.ref("signals/" + from).push({ from: myId, answer: myAnswer });
    } else if (answer) {
      await pc.setRemoteDescription(new RTCSessionDescription(answer));
    } else if (candidate) {
      await pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(() => {});
    }
  });
}

function setupChannel(peerId, channel) {
  connections[peerId].channel = channel;
  channel.binaryType = "arraybuffer";
  const peerName = allPeers[peerId]?.name || "Peer";
  
  channel.onopen = () => {
    if (connections[peerId].timeout) clearTimeout(connections[peerId].timeout);
    log(`<span style='color:#4CAF50;'>SECURE CHANNEL: ${peerName.toUpperCase()}</span>`, `status-${peerId}`);
    renderPeerList();
  };
  
  channel.onmessage = e => {
    const peerName = allPeers[peerId]?.name || "Peer";
  
    if (typeof e.data === "string") {
      // 1. Check for JSON (Files or System messages)
      try {
        const obj = JSON.parse(e.data);
        if (obj.type === "file-meta") {
          incomingFile = { metadata: obj, buffer: [] };
          log(`<i>Receiving: ${obj.name}</i>`);
          return;
        }
        if (obj.type === "system-bye") {
          disconnectFromPeer(peerId);
          return;
        }
        if (obj.type === "system-typing") {
          const indicator = document.getElementById("typingIndicator");
          indicator.textContent = `${peerName} is typing...`;
          if (connections[peerId].typingTimeout) clearTimeout(connections[peerId].typingTimeout);
          connections[peerId].typingTimeout = setTimeout(() => {
            indicator.textContent = "";
          }, 3000);
          return; // STOP here so it doesn't log the JSON
        }

        // ADD THIS: Handle Typing Stop
        if (obj.type === "system-typing-stop") {
          const indicator = document.getElementById("typingIndicator");
          indicator.textContent = ""; // Clear immediately
          if (connections[peerId].typingTimeout) clearTimeout(connections[peerId].typingTimeout);
          return; // STOP here so it doesn't log the JSON
        }
      } catch (err) {
        // Not JSON, continue to text processing
      }
  
      // 2. Mention Detection Logic
      const messageText = e.data;
      const mentionString = `@${myName}`;
      // Case-insensitive check for the mention
      const isMention = messageText.toLowerCase().includes(mentionString.toLowerCase());
  
      if (isMention) {
        // Play LOUD mention sound immediately
        const loudSound = document.getElementById("mentionSound");
        if (loudSound) {
          loudSound.volume = 1.0;
          loudSound.play().catch(() => {});
        }
        document.title = "üî¥ New Mention!";
        
        // Always trigger a desktop notification for mentions
        if (desktopNotificationsEnabled && Notification.permission === "granted") {
          new Notification(`üöÄ Mentioned by ${peerName}`, {
            body: messageText,
            icon: "https://cdn-icons-png.flaticon.com/512/733/733585.png"
          });
        }
      } else {
        // Regular notification (only if tab is inactive)
        notifyUser(peerName, messageText);
      }
  
      // 3. Log to UI with highlight if it's a mention
      const safeText = applyMarkdown(escapeHTML(messageText));
      log({ html: `<b>${peerName}:</b> ${linkify(safeText)}` }, null, isMention);
  
    } else {
      // 4. File Buffer Handling
      if (!incomingFile.metadata) return; // Guard against stray binary data
      
      incomingFile.buffer.push(e.data);
      const receivedSize = incomingFile.buffer.reduce((acc, cur) => acc + cur.byteLength, 0);
      
      if (receivedSize >= incomingFile.metadata.size) {
        const blob = new Blob(incomingFile.buffer, { type: incomingFile.metadata.mime });
        processCompletedFile(blob, incomingFile.metadata, peerName);
        incomingFile = { metadata: null, buffer: [] };
      }
    }
  };
}

function processCompletedFile(blob, meta, senderName) {
  // Trigger desktop notification with filename
  notifyUser(senderName, `üìé Sent a file: ${meta.name}`);

  const url = URL.createObjectURL(blob);
  const isImage = meta.mime.startsWith("image/");
  const isVideo = meta.mime.startsWith("video/");
  
  let mediaHtml = isImage ? `<img src="${url}" style="max-width:300px; border-radius:8px;">` :
                  isVideo ? `<video controls style="max-width:300px;"><source src="${url}" type="${meta.mime}">Fallback</video><br><a href="${url}" download="${meta.name}" style="color:#ff9900;">üì• Download</a>` :
                  `<a href="${url}" download="${meta.name}" style="color:#ff9900">Download ${meta.name}</a>`;
  
  log({ html: `<b>${senderName}:</b><br>${mediaHtml}` });
}

function broadcast(data) {
  for (let id in connections) {
    if (connections[id].channel?.readyState === "open") connections[id].channel.send(data);
  }
}

document.getElementById("send").onclick = sendMessage;

function sendMessage() {
  const text = msgInput.value.trim();
  if (!text) return;
  broadcast(JSON.stringify({ type: "system-typing-stop" }));
  broadcast(text);
  
  const safeText = applyMarkdown(escapeHTML(text));
  log({ html: `<b>You:</b> ${linkify(safeText)}` }, null, false);
  
  msgInput.value = "";
  msgInput.style.height = 'auto'; // Reset height
  
  lastTypingSent = 0;
}

async function handleFile(file) {
  if (!file) return;
  const buffer = await file.arrayBuffer();
  broadcast(JSON.stringify({ type: "file-meta", name: file.name, mime: file.type, size: file.size }));
  const chunkSize = 16384;
  for (let i = 0; i < buffer.byteLength; i += chunkSize) broadcast(buffer.slice(i, i + chunkSize));
  processCompletedFile(new Blob([buffer], {type: file.type}), {mime: file.type, name: file.name}, "You");
}

document.getElementById("fileInput").onchange = (e) => {
  handleFile(e.target.files[0]);
  e.target.value = "";
};

document.getElementById("msg").addEventListener("paste", async (e) => {
  const items = (e.clipboardData || e.originalEvent.clipboardData).items;
  for (let item of items) {
    if (item.kind === 'file') {
      e.preventDefault();
      handleFile(item.getAsFile());
    }
  }
});

document.getElementById("clearChat").onclick = () => {
  document.getElementById("messages").innerHTML = "";
};

document.getElementById("leaveAll").onclick = () => {
  if (!confirm("Disconnect from everyone?")) return;
  for (let id in connections) disconnectFromPeer(id);
  peersRef.child(myId).remove().then(() => {
    log("<b style='color:#e74c3c;'>OFFLINE</b>");
    renderPeerList();
  });
};

window.onbeforeunload = () => {
  for (let id in connections) disconnectFromPeer(id);
  peersRef.child(myId).remove();
};

// Detect when the user switches away from or back to the tab
window.onfocus = () => {
  isTabActive = true;
  document.title = "P2P Chat App"; // Reset title when user returns
};

window.onblur = () => {
  isTabActive = false;
};

login();

// links X
// embeds X
// @ requests X
// typing... X
</script>
</body>
</html>

